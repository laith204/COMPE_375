#define F_CPU 16000000UL
#include <avr/io.h>
#define BAUD 9600 // define baud
#define BAUDRATE ((F_CPU)/(BAUD*16UL)-1) // set baud rate

void uart_init (void)
{
	UBRR0H &= 0; //clears the register. not needed since its 0 from the start
	UBRR0H = (BAUDRATE>>8); // shift the register right by 8 bits
	// above line not needed for baud rate of 9600, and cpu frequency above of 16Mhz.
	UBRR0L = BAUDRATE; // set baud rate
	UCSR0B|= (1<<TXEN0); // enable transmitter
	UCSR0C|= (1<<UCSZ00)|(1<<UCSZ01); // 8bit data format
	UCSR0C &= ~(1<<4)|~(1<<5); //no parity, when bits 4 and 5 are 0, parity is disabled
	//above 2 lines not needed because they start at 0 parity, and it is set at 8 bits //automatically.
	UCSR0C &= ~(1<<USBS0) | (1<<USBS1); //sets stop bits to 1 onlyâ€¦ usbs = 0 now.. 0 = 1 stop bit
	//dont need above line because it starts off at 0.. Dont have to manually set it.
}

void port_init(){
	DDRD |= 0xF0; //turns bits 4-7 to 1 (outputs)
	DDRB &= 0xF0; //turns bits 0-3 to 0. (inputs)
	PORTB |= 0x0F;//turns pull up resistor on the chosen input bits (0-3).
	DDRC |= 0x10; //turns bit 4, port c to output. 
}

void uart_transmit (unsigned char data) {
	while (!( UCSR0A & (1<<5))){}; // wait while register is free
	UDR0 = data; // load data in the register
}

void uart_transmit1 (uint8_t data) {
	while (!( UCSR0A & (1<<5))){}; // wait while register is free
	UDR0 = data; // load data in the register
}

uint8_t Ton(int x, int y){
	 uint8_t Ton1[4][4] = { //values for OCR0A in steps - 1.. calculated outside of this code.. 
		{70, 66, 62, 59},
		{55, 52, 49, 46},
		{43, 41, 39, 37},
		{35, 33, 31, 29}
	};
	return Ton1[x][y];
}

 
void timer_init(){
	TCCR0A |= (1<<WGM01); //turns ctc mode on
	TCCR0B |= (1 << CS02) | (1 << CS00); //prescaler = 1024.. 
	OCR0A = 70; //71 steps with ps = 1024, = 45.45ms... 50% of this = ~23ms, max Ton 
	OCR0B = ((70 + 1) / 2) - 1; //50% duty cycle.. will be on for half a ms, off for the other half.. 
}

int main(void)
{
	port_init(); //initializes the ports
	uart_init(); //initializes the usart protocol values
	timer_init(); //initializes the timer
	char keyPad[4][4] = {
		{'1', '2', '3', 'A'},
		{'4', '5', '6', 'B'},
		{'7', '8', '9', 'C'},
		{'*', '0', '#', 'D'}
	};
	int i, j;
	while(1){
		for(i = 4; i < 8; i++){ // i = rows, port d (4-7)
			PORTD &= ~(1<<i); //sets a single row to logic 0 to see if that row is pressed
			for (j = 0; j < 4; j++){ //j = columns, port b (0-3)
				if(!(PINB & (1<<j))){ //if that column reads a logic 0, that means the row and column switch (keypad button) is pressed
					uint8_t freq = Ton((i-4),j);
					OCR0A = freq;
					OCR0B = ((freq + 1) / 2) - 1; //50% duty cycle
					uart_transmit(keyPad[i-4][j]); //transmits the keypad button that is pressed	
					uart_transmit(" ");
					uart_transmit1(freq);
					uart_transmit('\r\n');
					//while(!(PINB & (1<<j))){} //busy while that will stop the program from moving on until the keypad button is released
					PORTB |= (1<<5);
				}
			}
			PORTD |= (1<<i); // sets that row that was set to logic 0 back to logic 1 so it can then check another row
		}
		PORTC |= (1<<4); //turns PORTC bit 4 to logic 1
		while ( (TIFR0 & (1 << OCF0B) ) == 0){} // wait for OCR0B overflow event
		TIFR0 |= (1 << OCF0B); // reset OCR0B overflow flag
		PORTC &= ~(1<<4); //turns PORTC bit 4 to logic 0
		while ( (TIFR0 & (1 << OCF0A) ) == 0){} // wait for OCR0A overflow event
		TIFR0 |= (1 << OCF0A); // reset OCR0A overflow flag
	}
}
